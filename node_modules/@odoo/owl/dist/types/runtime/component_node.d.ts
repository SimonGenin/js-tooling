import type { App, Env } from "./app";
import { BDom, VNode } from "./blockdom";
import { getSubscriptions, NonReactive, Reactive } from "./reactivity";
import { Component, ComponentConstructor } from "./component";
import { Fiber, MountFiber, MountOptions } from "./fibers";
import { STATUS } from "./status";
export declare function getCurrent(): ComponentNode;
export declare function useComponent(): Component;
/**
 * Creates a reactive object that will be observed by the current component.
 * Reading data from the returned object (eg during rendering) will cause the
 * component to subscribe to that data and be rerendered when it changes.
 *
 * @param state the state to observe
 * @returns a reactive object that will cause the component to re-render on
 *  relevant changes
 * @see reactive
 */
export declare function useState<T extends object>(state: T): Reactive<T> | NonReactive<T>;
declare type Props = {
    [key: string]: any;
};
export declare function component<P extends Props>(name: string | ComponentConstructor<P>, props: P, key: string, ctx: ComponentNode, parent: any): ComponentNode<P>;
declare type LifecycleHook = Function;
export declare class ComponentNode<P extends Props = any, E = any> implements VNode<ComponentNode<P, E>> {
    el?: HTMLElement | Text | undefined;
    app: App;
    fiber: Fiber | null;
    component: Component<P, E>;
    bdom: BDom | null;
    status: STATUS;
    forceNextRender: boolean;
    parentKey: string | null;
    props: P;
    renderFn: Function;
    parent: ComponentNode | null;
    level: number;
    childEnv: Env;
    children: {
        [key: string]: ComponentNode;
    };
    refs: any;
    willStart: LifecycleHook[];
    willUpdateProps: LifecycleHook[];
    willUnmount: LifecycleHook[];
    mounted: LifecycleHook[];
    willPatch: LifecycleHook[];
    patched: LifecycleHook[];
    willDestroy: LifecycleHook[];
    constructor(C: ComponentConstructor<P, E>, props: P, app: App, parent: ComponentNode | null, parentKey: string | null);
    mountComponent(target: any, options?: MountOptions): void;
    initiateRender(fiber: Fiber | MountFiber): Promise<void>;
    render(deep: boolean): Promise<void>;
    destroy(): void;
    _destroy(): void;
    updateAndRender(props: P, parentFiber: Fiber): Promise<void>;
    /**
     * Finds a child that has dom that is not yet updated, and update it. This
     * method is meant to be used only in the context of repatching the dom after
     * a mounted hook failed and was handled.
     */
    updateDom(): void;
    firstNode(): Node | undefined;
    mount(parent: HTMLElement, anchor: ChildNode): void;
    moveBefore(other: ComponentNode | null, afterNode: Node | null): void;
    patch(): void;
    _patch(): void;
    beforeRemove(): void;
    remove(): void;
    get name(): string;
    get subscriptions(): ReturnType<typeof getSubscriptions>;
}
export {};
